(window.webpackJsonp=window.webpackJsonp||[]).push([[59],{201:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return i})),n.d(t,"metadata",(function(){return c})),n.d(t,"rightToc",(function(){return l})),n.d(t,"default",(function(){return b}));var r=n(1),a=n(9),o=(n(0),n(213)),i={last_modified_on:"2020-03-13",id:"presenting-gnet",title:"Presenting Gnet",description:"Hello World! We present you, gnet!",author_github:"https://github.com/panjf2000",tags:["type: announcement","domain: presentation"]},c={permalink:"/blog/presenting-gnet",source:"@site/blog/2020-03-13-presenting-gnet.md",description:"Hello World! We present you, gnet!",date:"2020-03-13T00:00:00.000Z",tags:[{label:"type: announcement",permalink:"/blog/tags/type-announcement"},{label:"domain: presentation",permalink:"/blog/tags/domain-presentation"}],title:"Presenting Gnet",readingTime:22.94,truncated:!1,prevItem:{title:"Gnet \u5bfc\u89c6",permalink:"/blog/presenting-gnet-cn"}},l=[{value:"Networking Model of Multiple Threads/Goroutines",id:"networking-model-of-multiple-threadsgoroutines",children:[{value:"Multiple Reactors",id:"multiple-reactors",children:[]},{value:"Multiple Reactors + Goroutine Pool",id:"multiple-reactors--goroutine-pool",children:[]}]},{value:"Reusable and auto-scaling Ring Buffer",id:"reusable-and-auto-scaling-ring-buffer",children:[]},{value:"Prerequisites",id:"prerequisites",children:[]},{value:"Installation",id:"installation",children:[]},{value:"Usage Examples",id:"usage-examples",children:[{value:"Echo server without blocking logic",id:"echo-server-without-blocking-logic",children:[]},{value:"Echo server with blocking logic",id:"echo-server-with-blocking-logic",children:[]}]},{value:"I/O Events",id:"io-events",children:[]},{value:"Ticker",id:"ticker",children:[]},{value:"UDP",id:"udp",children:[]},{value:"Unix Domain Socket",id:"unix-domain-socket",children:[]},{value:"Multi-threads",id:"multi-threads",children:[]},{value:"Load Balancing",id:"load-balancing",children:[]},{value:"SO_REUSEPORT",id:"so_reuseport",children:[]},{value:"Multiple built-in codecs for TCP stream",id:"multiple-built-in-codecs-for-tcp-stream",children:[]},{value:"Benchmarks on TechEmpower",id:"benchmarks-on-techempower",children:[]},{value:"Contrasts to the similar networking libraries",id:"contrasts-to-the-similar-networking-libraries",children:[]},{value:"On Linux (epoll)",id:"on-linux-epoll",children:[{value:"Test Environment",id:"test-environment",children:[]}]},{value:"On FreeBSD (kqueue)",id:"on-freebsd-kqueue",children:[{value:"Test Environment",id:"test-environment-1",children:[]}]}],s={rightToc:l};function b(e){var t=e.components,n=Object(a.a)(e,["components"]);return Object(o.b)("wrapper",Object(r.a)({},s,n,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",{align:"center"},Object(o.b)("img",{src:"https://raw.githubusercontent.com/panjf2000/logos/master/gnet/logo.png",alt:"gnet"})),Object(o.b)("h1",{id:"-introduction"},"\ud83d\udcd6 Introduction"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"gnet")," is an event-driven networking framework that is fast and lightweight. It makes direct ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"https://en.wikipedia.org/wiki/Epoll"}),"epoll")," and ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"https://en.wikipedia.org/wiki/Kqueue"}),"kqueue")," syscalls rather than using the standard Go ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"https://golang.org/pkg/net/"}),"net")," package and works in a similar manner as ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"https://github.com/netty/netty"}),"netty")," and ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"https://github.com/libuv/libuv"}),"libuv"),", which makes ",Object(o.b)("inlineCode",{parentName:"p"},"gnet")," achieve a much higher performance than Go ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"https://golang.org/pkg/net/"}),"net"),"."),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"gnet")," is not designed to displace the standard Go ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"https://golang.org/pkg/net/"}),"net")," package, but to create a networking server framework for Go that performs on par with ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"http://redis.io"}),"Redis")," and ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"http://www.haproxy.org"}),"Haproxy")," for networking packets handling."),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"gnet")," sells itself as a high-performance, lightweight, non-blocking, event-driven networking framework written in pure Go which works on transport layer with TCP/UDP protocols and Unix Domain Socket , so it allows developers to implement their own protocols(HTTP, RPC, WebSocket, Redis, etc.) of application layer upon ",Object(o.b)("inlineCode",{parentName:"p"},"gnet")," for building  diversified network applications, for instance, you get an HTTP Server or Web Framework if you implement HTTP protocol upon ",Object(o.b)("inlineCode",{parentName:"p"},"gnet")," while you have a Redis Server done with the implementation of Redis protocol upon ",Object(o.b)("inlineCode",{parentName:"p"},"gnet")," and so on."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},Object(o.b)("inlineCode",{parentName:"strong"},"gnet")," derives from the project: ",Object(o.b)("inlineCode",{parentName:"strong"},"evio")," while having a much higher performance and more features.")),Object(o.b)("h1",{id:"-features"},"\ud83d\ude80 Features"),Object(o.b)("ul",{className:"contains-task-list"},Object(o.b)("li",Object(r.a)({parentName:"ul"},{className:"task-list-item"}),Object(o.b)("input",Object(r.a)({parentName:"li"},{type:"checkbox",checked:!0,disabled:!0}))," ",Object(o.b)("a",Object(r.a)({parentName:"li"},{href:"#-performance"}),"High-performance")," event-loop under networking model of multiple threads/goroutines"),Object(o.b)("li",Object(r.a)({parentName:"ul"},{className:"task-list-item"}),Object(o.b)("input",Object(r.a)({parentName:"li"},{type:"checkbox",checked:!0,disabled:!0}))," ","Built-in goroutine pool powered by the library ",Object(o.b)("a",Object(r.a)({parentName:"li"},{href:"https://github.com/panjf2000/ants"}),"ants")),Object(o.b)("li",Object(r.a)({parentName:"ul"},{className:"task-list-item"}),Object(o.b)("input",Object(r.a)({parentName:"li"},{type:"checkbox",checked:!0,disabled:!0}))," ","Built-in memory pool with bytes powered by the library ",Object(o.b)("a",Object(r.a)({parentName:"li"},{href:"https://github.com/valyala/bytebufferpool"}),"bytebufferpool")),Object(o.b)("li",Object(r.a)({parentName:"ul"},{className:"task-list-item"}),Object(o.b)("input",Object(r.a)({parentName:"li"},{type:"checkbox",checked:!0,disabled:!0}))," ","Lock-free during the entire runtime"),Object(o.b)("li",Object(r.a)({parentName:"ul"},{className:"task-list-item"}),Object(o.b)("input",Object(r.a)({parentName:"li"},{type:"checkbox",checked:!0,disabled:!0}))," ","Concise and easy-to-use APIs"),Object(o.b)("li",Object(r.a)({parentName:"ul"},{className:"task-list-item"}),Object(o.b)("input",Object(r.a)({parentName:"li"},{type:"checkbox",checked:!0,disabled:!0}))," ","Efficient and reusable memory buffer: Ring-Buffer"),Object(o.b)("li",Object(r.a)({parentName:"ul"},{className:"task-list-item"}),Object(o.b)("input",Object(r.a)({parentName:"li"},{type:"checkbox",checked:!0,disabled:!0}))," ","Supporting multiple protocols/IPC mechanism: ",Object(o.b)("inlineCode",{parentName:"li"},"TCP"),", ",Object(o.b)("inlineCode",{parentName:"li"},"UDP")," and ",Object(o.b)("inlineCode",{parentName:"li"},"Unix Domain Socket")),Object(o.b)("li",Object(r.a)({parentName:"ul"},{className:"task-list-item"}),Object(o.b)("input",Object(r.a)({parentName:"li"},{type:"checkbox",checked:!0,disabled:!0}))," ","Supporting multiple load-balancing algorithms: ",Object(o.b)("inlineCode",{parentName:"li"},"Round-Robin"),", ",Object(o.b)("inlineCode",{parentName:"li"},"Source-Addr-Hash")," and ",Object(o.b)("inlineCode",{parentName:"li"},"Least-Connections")),Object(o.b)("li",Object(r.a)({parentName:"ul"},{className:"task-list-item"}),Object(o.b)("input",Object(r.a)({parentName:"li"},{type:"checkbox",checked:!0,disabled:!0}))," ","Supporting two event-driven mechanisms: ",Object(o.b)("inlineCode",{parentName:"li"},"epoll")," on ",Object(o.b)("strong",{parentName:"li"},"Linux")," and ",Object(o.b)("inlineCode",{parentName:"li"},"kqueue")," on ",Object(o.b)("strong",{parentName:"li"},"FreeBSD/DragonFly/Darwin")),Object(o.b)("li",Object(r.a)({parentName:"ul"},{className:"task-list-item"}),Object(o.b)("input",Object(r.a)({parentName:"li"},{type:"checkbox",checked:!0,disabled:!0}))," ","Supporting asynchronous write operation"),Object(o.b)("li",Object(r.a)({parentName:"ul"},{className:"task-list-item"}),Object(o.b)("input",Object(r.a)({parentName:"li"},{type:"checkbox",checked:!0,disabled:!0}))," ","Flexible ticker event"),Object(o.b)("li",Object(r.a)({parentName:"ul"},{className:"task-list-item"}),Object(o.b)("input",Object(r.a)({parentName:"li"},{type:"checkbox",checked:!0,disabled:!0}))," ","SO_REUSEPORT socket option"),Object(o.b)("li",Object(r.a)({parentName:"ul"},{className:"task-list-item"}),Object(o.b)("input",Object(r.a)({parentName:"li"},{type:"checkbox",checked:!0,disabled:!0}))," ","Built-in multiple codecs to encode/decode network frames into/from TCP stream: LineBasedFrameCodec, DelimiterBasedFrameCodec, FixedLengthFrameCodec and LengthFieldBasedFrameCodec, referencing ",Object(o.b)("a",Object(r.a)({parentName:"li"},{href:"https://netty.io/4.1/api/io/netty/handler/codec/package-summary.html"}),"netty codec"),", also supporting customized codecs"),Object(o.b)("li",Object(r.a)({parentName:"ul"},{className:"task-list-item"}),Object(o.b)("input",Object(r.a)({parentName:"li"},{type:"checkbox",checked:!0,disabled:!0}))," ","Supporting Windows platform with ",Object(o.b)("del",{parentName:"li"},"event-driven mechanism of IOCP")," Go stdlib: net"),Object(o.b)("li",Object(r.a)({parentName:"ul"},{className:"task-list-item"}),Object(o.b)("input",Object(r.a)({parentName:"li"},{type:"checkbox",checked:!1,disabled:!0}))," ","Implementation of ",Object(o.b)("inlineCode",{parentName:"li"},"gnet")," Client")),Object(o.b)("h1",{id:"-key-designs"},"\ud83d\udca1 Key Designs"),Object(o.b)("h2",{id:"networking-model-of-multiple-threadsgoroutines"},"Networking Model of Multiple Threads/Goroutines"),Object(o.b)("h3",{id:"multiple-reactors"},"Multiple Reactors"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"gnet")," redesigns and implements a new built-in networking model of multiple threads/goroutines: \u300emultiple reactors\u300f which is also the default networking model of multiple threads in ",Object(o.b)("inlineCode",{parentName:"p"},"netty"),", Here's the schematic diagram:"),Object(o.b)("p",{align:"center"},Object(o.b)("img",{alt:"multi_reactor",src:"https://raw.githubusercontent.com/panjf2000/illustrations/master/go/multi-reactors.png"})),Object(o.b)("p",null,"and it works as the following sequence diagram:"),Object(o.b)("p",{align:"center"},Object(o.b)("img",{alt:"reactor",src:"https://raw.githubusercontent.com/panjf2000/illustrations/master/go/multi-reactors-sequence-diagram.png"})),Object(o.b)("h3",{id:"multiple-reactors--goroutine-pool"},"Multiple Reactors + Goroutine Pool"),Object(o.b)("p",null,"You may ask me a question: what if my business logic in ",Object(o.b)("inlineCode",{parentName:"p"},"EventHandler.React"),"  contains some blocking code which leads to blocking in event-loop of ",Object(o.b)("inlineCode",{parentName:"p"},"gnet"),", what is the solution for this kind of situation\uff1f"),Object(o.b)("p",null,"As you know, there is a most important tenet when writing code under ",Object(o.b)("inlineCode",{parentName:"p"},"gnet"),": you should never block the event-loop goroutine in the ",Object(o.b)("inlineCode",{parentName:"p"},"EventHandler.React"),", which is also the most important tenet in ",Object(o.b)("inlineCode",{parentName:"p"},"netty"),", otherwise, it will result in a low throughput in your ",Object(o.b)("inlineCode",{parentName:"p"},"gnet")," server."),Object(o.b)("p",null,"And the solution to that could be found in the subsequent networking model of multiple threads/goroutines in ",Object(o.b)("inlineCode",{parentName:"p"},"gnet"),": \u300emultiple reactors with thread/goroutine pool\u300fwhich pulls you out from the blocking mire, it will construct a worker-pool with fixed capacity and put those blocking jobs in ",Object(o.b)("inlineCode",{parentName:"p"},"EventHandler.React")," into the worker-pool to make the event-loop goroutines non-blocking."),Object(o.b)("p",null,"The networking model:\u300emultiple reactors with thread/goroutine pool\u300fdissolves the blocking jobs by introducing a goroutine pool, as shown below:"),Object(o.b)("p",{align:"center"},Object(o.b)("img",{alt:"multi_reactor_thread_pool",src:"https://raw.githubusercontent.com/panjf2000/illustrations/master/go/multi-reactors%2Bthread-pool.png"})),Object(o.b)("p",null,"and it works as the following sequence diagram:"),Object(o.b)("p",{align:"center"},Object(o.b)("img",{alt:"multi-reactors",src:"https://raw.githubusercontent.com/panjf2000/illustrations/master/go/multi-reactors%2Bthread-pool-sequence-diagram.png"})),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"gnet")," implements the networking model:\u300emultiple reactors with thread/goroutine pool\u300fby the aid of a high-performance goroutine pool called ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"https://github.com/panjf2000/ants"}),"ants")," that allows you to manage and recycle a massive number of goroutines in your concurrent programs, the full features and usages in ",Object(o.b)("inlineCode",{parentName:"p"},"ants")," are documented ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"https://pkg.go.dev/github.com/panjf2000/ants/v2?tab=doc"}),"here"),"."),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"gnet")," integrates ",Object(o.b)("inlineCode",{parentName:"p"},"ants")," and provides the ",Object(o.b)("inlineCode",{parentName:"p"},"pool.goroutine.Default()")," method that you can call to instantiate a ",Object(o.b)("inlineCode",{parentName:"p"},"ants")," pool where you are able to put your blocking code logic and call the function ",Object(o.b)("inlineCode",{parentName:"p"},"gnet.Conn.AsyncWrite([]byte)")," to send out data asynchronously after you finish the blocking process and get the output data, which makes the goroutine of event-loop non-blocking."),Object(o.b)("p",null,"The details about integrating ",Object(o.b)("inlineCode",{parentName:"p"},"gnet"),"  with ",Object(o.b)("inlineCode",{parentName:"p"},"ants")," are shown ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#echo-server-with-blocking-logic"}),"here"),"."),Object(o.b)("h2",{id:"reusable-and-auto-scaling-ring-buffer"},"Reusable and auto-scaling Ring Buffer"),Object(o.b)("p",null,"There are two ring-buffers inside ",Object(o.b)("inlineCode",{parentName:"p"},"gnet"),": inbound buffer and outbound buffer to buffer and manage inbound/outbound network data, ring-buffer inside gnet is designed and tuned to reuse memory and be auto-scaling on demand."),Object(o.b)("p",null,"The purpose of implementing inbound and outbound ring-buffers in ",Object(o.b)("inlineCode",{parentName:"p"},"gnet")," is to transfer the logic of buffering and managing network data based on application protocol upon TCP stream from business server to framework and unify the network data buffer, which minimizes the complexity of business code so that developers are able to concentrate on business logic instead of the underlying implementation."),Object(o.b)("p",{align:"center"},Object(o.b)("img",{src:"https://raw.githubusercontent.com/panjf2000/illustrations/master/go/ring-buffer.gif"})),Object(o.b)("h1",{id:"-getting-started"},"\ud83c\udf89 Getting Started"),Object(o.b)("h2",{id:"prerequisites"},"Prerequisites"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"gnet")," requires Go 1.9 or later."),Object(o.b)("h2",{id:"installation"},"Installation"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-powershell"}),"go get -u github.com/panjf2000/gnet\n")),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"gnet")," is available as a Go module, with ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"https://github.com/golang/go/wiki/Modules"}),"Go 1.11 Modules")," support (Go 1.11+), just simply ",Object(o.b)("inlineCode",{parentName:"p"},'import "github.com/panjf2000/gnet"')," in your source code and ",Object(o.b)("inlineCode",{parentName:"p"},"go [build|run|test]")," will download the necessary dependencies automatically."),Object(o.b)("h2",{id:"usage-examples"},"Usage Examples"),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"The detailed documentation is located in here: ",Object(o.b)("a",Object(r.a)({parentName:"strong"},{href:"https://pkg.go.dev/github.com/panjf2000/gnet?tab=doc"}),"docs of gnet"),", but let's pass through the brief instructions first.")),Object(o.b)("p",null,"It is easy to create a network server with ",Object(o.b)("inlineCode",{parentName:"p"},"gnet"),". All you have to do is just to make your implementation of ",Object(o.b)("inlineCode",{parentName:"p"},"gnet.EventHandler")," interface and register your event-handler functions to it, then pass it to the ",Object(o.b)("inlineCode",{parentName:"p"},"gnet.Serve")," function along with the binding address(es). Each connection is represented as a ",Object(o.b)("inlineCode",{parentName:"p"},"gnet.Conn")," interface that is passed to various events to differentiate the clients. At any point you can close a connection or shutdown the server by return a ",Object(o.b)("inlineCode",{parentName:"p"},"Close")," or ",Object(o.b)("inlineCode",{parentName:"p"},"Shutdown")," action from an event function."),Object(o.b)("p",null,"The simplest example to get you started playing with ",Object(o.b)("inlineCode",{parentName:"p"},"gnet")," would be the echo server. So here you are, a simplest echo server upon ",Object(o.b)("inlineCode",{parentName:"p"},"gnet")," that is listening on port 9000:"),Object(o.b)("h3",{id:"echo-server-without-blocking-logic"},"Echo server without blocking logic"),Object(o.b)("details",null,Object(o.b)("summary",null," Old version(<=v1.0.0-rc.4)  "),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-go"}),'package main\n\nimport (\n    "log"\n\n    "github.com/panjf2000/gnet"\n)\n\ntype echoServer struct {\n    *gnet.EventServer\n}\n\nfunc (es *echoServer) React(c gnet.Conn) (out []byte, action gnet.Action) {\n    out = c.Read()\n    c.ResetBuffer()\n    return\n}\n\nfunc main() {\n    echo := new(echoServer)\n    log.Fatal(gnet.Serve(echo, "tcp://:9000", gnet.WithMulticore(true)))\n}\n'))),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-go"}),'package main\n\nimport (\n    "log"\n\n    "github.com/panjf2000/gnet"\n)\n\ntype echoServer struct {\n    *gnet.EventServer\n}\n\nfunc (es *echoServer) React(frame []byte, c gnet.Conn) (out []byte, action gnet.Action) {\n    out = frame\n    return\n}\n\nfunc main() {\n    echo := new(echoServer)\n    log.Fatal(gnet.Serve(echo, "tcp://:9000", gnet.WithMulticore(true)))\n}\n')),Object(o.b)("p",null,"As you can see, this example of echo server only sets up the ",Object(o.b)("inlineCode",{parentName:"p"},"EventHandler.React")," function where you commonly write your main business code and it will be called once the server receives input data from a client. What you should know is that the input parameter: ",Object(o.b)("inlineCode",{parentName:"p"},"frame")," is a complete packet which has been decoded by the codec, as a general rule, you should implement the ",Object(o.b)("inlineCode",{parentName:"p"},"gnet")," ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"https://pkg.go.dev/github.com/panjf2000/gnet?tab=doc#ICodec"}),"codec interface")," as the business codec to packet and unpacket TCP stream, but if you don't, your ",Object(o.b)("inlineCode",{parentName:"p"},"gnet")," server is going to work with the ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"https://pkg.go.dev/github.com/panjf2000/gnet?tab=doc#BuiltInFrameCodec"}),"default codec")," under the acquiescence, which means all data inculding latest data and previous data in buffer will be stored in the input parameter: ",Object(o.b)("inlineCode",{parentName:"p"},"frame")," when ",Object(o.b)("inlineCode",{parentName:"p"},"EventHandler.React")," is being triggered. The output data will be then encoded and sent back to that client by assigning the ",Object(o.b)("inlineCode",{parentName:"p"},"out")," variable and returning it after your business code finish processing data(in this case, it just echo the data back)."),Object(o.b)("h3",{id:"echo-server-with-blocking-logic"},"Echo server with blocking logic"),Object(o.b)("details",null,Object(o.b)("summary",null," Old version(<=v1.0.0-rc.4)  "),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-go"}),'package main\n\nimport (\n    "log"\n    "time"\n\n    "github.com/panjf2000/gnet"\n    "github.com/panjf2000/gnet/pool/goroutine"\n)\n\ntype echoServer struct {\n    *gnet.EventServer\n    pool *goroutine.Pool\n}\n\nfunc (es *echoServer) React(c gnet.Conn) (out []byte, action gnet.Action) {\n    data := append([]byte{}, c.Read()...)\n    c.ResetBuffer()\n\n    // Use ants pool to unblock the event-loop.\n    _ = es.pool.Submit(func() {\n        time.Sleep(1 * time.Second)\n        c.AsyncWrite(data)\n    })\n\n    return\n}\n\nfunc main() {\n    p := goroutine.Default()\n    defer p.Release()\n    \n    echo := &echoServer{pool: p}\n    log.Fatal(gnet.Serve(echo, "tcp://:9000", gnet.WithMulticore(true)))\n}\n'))),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-go"}),'package main\n\nimport (\n    "log"\n    "time"\n\n    "github.com/panjf2000/gnet"\n    "github.com/panjf2000/gnet/pool/goroutine"\n)\n\ntype echoServer struct {\n    *gnet.EventServer\n    pool *goroutine.Pool\n}\n\nfunc (es *echoServer) React(frame []byte, c gnet.Conn) (out []byte, action gnet.Action) {\n    data := append([]byte{}, frame...)\n\n    // Use ants pool to unblock the event-loop.\n    _ = es.pool.Submit(func() {\n        time.Sleep(1 * time.Second)\n        c.AsyncWrite(data)\n    })\n\n    return\n}\n\nfunc main() {\n    p := goroutine.Default()\n    defer p.Release()\n\n    echo := &echoServer{pool: p}\n    log.Fatal(gnet.Serve(echo, "tcp://:9000", gnet.WithMulticore(true)))\n}\n')),Object(o.b)("p",null,"Like I said in the \u300eMultiple Reactors + Goroutine Pool\u300fsection, if there are blocking code in your business logic, then you ought to turn them into non-blocking code in any way, for instance, you can wrap them into a goroutine, but it will result in a massive amount of goroutines if massive traffic is passing through your server so I would suggest you utilize a goroutine pool like ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"https://github.com/panjf2000/ants"}),"ants")," to manage those goroutines and reduce the cost of system resources."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"All gnet examples:")),Object(o.b)("details",null,Object(o.b)("summary",null," TCP Echo Server "),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-go"}),'package main\n\nimport (\n    "flag"\n    "fmt"\n    "log"\n\n    "github.com/panjf2000/gnet"\n)\n\ntype echoServer struct {\n    *gnet.EventServer\n}\n\nfunc (es *echoServer) OnInitComplete(srv gnet.Server) (action gnet.Action) {\n    log.Printf("Echo server is listening on %s (multi-cores: %t, loops: %d)\\n",\n        srv.Addr.String(), srv.Multicore, srv.NumEventLoop)\n    return\n}\n\nfunc (es *echoServer) React(frame []byte, c gnet.Conn) (out []byte, action gnet.Action) {\n    // Echo synchronously.\n    out = frame\n    return\n\n    /*\n        // Echo asynchronously.\n        data := append([]byte{}, frame...)\n        go func() {\n            time.Sleep(time.Second)\n            c.AsyncWrite(data)\n        }()\n        return\n    */\n}\n\nfunc main() {\n    var port int\n    var multicore, reuseport bool\n\n    // Example command: go run echo.go --port 9000 --multicore=true --reuseport=true\n    flag.IntVar(&port, "port", 9000, "--port 9000")\n    flag.BoolVar(&multicore, "multicore", false, "--multicore true")\n    flag.BoolVar(&reuseport, "reuseport", false, "--reuseport true")\n    flag.Parse()\n    echo := new(echoServer)\n    log.Fatal(gnet.Serve(echo, fmt.Sprintf("tcp://:%d", port), gnet.WithMulticore(multicore), gnet.WithReusePort(reuseport)))\n}\n'))),Object(o.b)("details",null,Object(o.b)("summary",null," UDP Echo Server "),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-go"}),'package main\n\nimport (\n    "flag"\n    "fmt"\n    "log"\n\n    "github.com/panjf2000/gnet"\n)\n\ntype echoServer struct {\n    *gnet.EventServer\n}\n\nfunc (es *echoServer) OnInitComplete(srv gnet.Server) (action gnet.Action) {\n    log.Printf("UDP Echo server is listening on %s (multi-cores: %t, loops: %d)\\n",\n        srv.Addr.String(), srv.Multicore, srv.NumEventLoop)\n    return\n}\n\nfunc (es *echoServer) React(frame []byte, c gnet.Conn) (out []byte, action gnet.Action) {\n    // Echo synchronously.\n    out = frame\n    return\n\n    /*\n        // Echo asynchronously.\n        data := append([]byte{}, frame...)\n        go func() {\n            time.Sleep(time.Second)\n            c.SendTo(data)\n        }()\n        return\n    */\n}\n\nfunc main() {\n    var port int\n    var multicore, reuseport bool\n\n    // Example command: go run echo.go --port 9000 --multicore=true --reuseport=true\n    flag.IntVar(&port, "port", 9000, "--port 9000")\n    flag.BoolVar(&multicore, "multicore", false, "--multicore true")\n    flag.BoolVar(&reuseport, "reuseport", false, "--reuseport true")\n    flag.Parse()\n    echo := new(echoServer)\n    log.Fatal(gnet.Serve(echo, fmt.Sprintf("udp://:%d", port), gnet.WithMulticore(multicore), gnet.WithReusePort(reuseport)))\n}\n'))),Object(o.b)("details",null,Object(o.b)("summary",null," UDS Echo Server "),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-go"}),'package main\n\nimport (\n    "flag"\n    "fmt"\n    "log"\n\n    "github.com/panjf2000/gnet"\n)\n\ntype echoServer struct {\n    *gnet.EventServer\n}\n\nfunc (es *echoServer) OnInitComplete(srv gnet.Server) (action gnet.Action) {\n    log.Printf("Echo server is listening on %s (multi-cores: %t, loops: %d)\\n",\n        srv.Addr.String(), srv.Multicore, srv.NumEventLoop)\n    return\n}\n\nfunc (es *echoServer) React(frame []byte, c gnet.Conn) (out []byte, action gnet.Action) {\n    // Echo synchronously.\n    out = frame\n    return\n\n    /*\n        // Echo asynchronously.\n        data := append([]byte{}, frame...)\n        go func() {\n            time.Sleep(time.Second)\n            c.AsyncWrite(data)\n        }()\n        return\n    */\n}\n\nfunc main() {\n    var addr string\n    var multicore bool\n\n    // Example command: go run echo.go --sock echo.sock --multicore=true\n    flag.StringVar(&addr, "sock", "echo.sock", "--port 9000")\n    flag.BoolVar(&multicore, "multicore", false, "--multicore true")\n    flag.Parse()\n\n    echo := new(echoServer)\n    log.Fatal(gnet.Serve(echo, fmt.Sprintf("unix://%s", addr), gnet.WithMulticore(multicore)))\n}\n'))),Object(o.b)("details",null,Object(o.b)("summary",null," HTTP Server "),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-go"}),'package main\n\nimport (\n    "flag"\n    "fmt"\n    "log"\n    "strconv"\n    "strings"\n    "time"\n    "unsafe"\n\n    "github.com/panjf2000/gnet"\n)\n\nvar res string\n\ntype request struct {\n    proto, method string\n    path, query   string\n    head, body    string\n    remoteAddr    string\n}\n\ntype httpServer struct {\n    *gnet.EventServer\n}\n\nvar (\n    errMsg      = "Internal Server Error"\n    errMsgBytes = []byte(errMsg)\n)\n\ntype httpCodec struct {\n    req request\n}\n\nfunc (hc *httpCodec) Encode(c gnet.Conn, buf []byte) (out []byte, err error) {\n    if c.Context() == nil {\n        return buf, nil\n    }\n    return appendResp(out, "500 Error", "", errMsg+"\\n"), nil\n}\n\nfunc (hc *httpCodec) Decode(c gnet.Conn) (out []byte, err error) {\n    buf := c.Read()\n    c.ResetBuffer()\n\n    // process the pipeline\n    var leftover []byte\npipeline:\n    leftover, err = parseReq(buf, &hc.req)\n    // bad thing happened\n    if err != nil {\n        c.SetContext(err)\n        return nil, err\n    } else if len(leftover) == len(buf) {\n        // request not ready, yet\n        return\n    }\n    out = appendHandle(out, res)\n    buf = leftover\n    goto pipeline\n}\n\nfunc (hs *httpServer) OnInitComplete(srv gnet.Server) (action gnet.Action) {\n    log.Printf("HTTP server is listening on %s (multi-cores: %t, loops: %d)\\n",\n        srv.Addr.String(), srv.Multicore, srv.NumEventLoop)\n    return\n}\n\nfunc (hs *httpServer) React(frame []byte, c gnet.Conn) (out []byte, action gnet.Action) {\n    if c.Context() != nil {\n        // bad thing happened\n        out = errMsgBytes\n        action = gnet.Close\n        return\n    }\n    // handle the request\n    out = frame\n    return\n}\n\nfunc main() {\n    var port int\n    var multicore bool\n\n    // Example command: go run http.go --port 8080 --multicore=true\n    flag.IntVar(&port, "port", 8080, "server port")\n    flag.BoolVar(&multicore, "multicore", true, "multicore")\n    flag.Parse()\n\n    res = "Hello World!\\r\\n"\n\n    http := new(httpServer)\n    hc := new(httpCodec)\n\n    // Start serving!\n    log.Fatal(gnet.Serve(http, fmt.Sprintf("tcp://:%d", port), gnet.WithMulticore(multicore), gnet.WithCodec(hc)))\n}\n\n// appendHandle handles the incoming request and appends the response to\n// the provided bytes, which is then returned to the caller.\nfunc appendHandle(b []byte, res string) []byte {\n    return appendResp(b, "200 OK", "", res)\n}\n\n// appendResp will append a valid http response to the provide bytes.\n// The status param should be the code plus text such as "200 OK".\n// The head parameter should be a series of lines ending with "\\r\\n" or empty.\nfunc appendResp(b []byte, status, head, body string) []byte {\n    b = append(b, "HTTP/1.1"...)\n    b = append(b, \' \')\n    b = append(b, status...)\n    b = append(b, \'\\r\', \'\\n\')\n    b = append(b, "Server: gnet\\r\\n"...)\n    b = append(b, "Date: "...)\n    b = time.Now().AppendFormat(b, "Mon, 02 Jan 2006 15:04:05 GMT")\n    b = append(b, \'\\r\', \'\\n\')\n    if len(body) > 0 {\n        b = append(b, "Content-Length: "...)\n        b = strconv.AppendInt(b, int64(len(body)), 10)\n        b = append(b, \'\\r\', \'\\n\')\n    }\n    b = append(b, head...)\n    b = append(b, \'\\r\', \'\\n\')\n    if len(body) > 0 {\n        b = append(b, body...)\n    }\n    return b\n}\n\nfunc b2s(b []byte) string {\n    return *(*string)(unsafe.Pointer(&b))\n}\n\n// parseReq is a very simple http request parser. This operation\n// waits for the entire payload to be buffered before returning a\n// valid request.\nfunc parseReq(data []byte, req *request) (leftover []byte, err error) {\n    sdata := b2s(data)\n    var i, s int\n    var head string\n    var clen int\n    q := -1\n    // method, path, proto line\n    for ; i < len(sdata); i++ {\n        if sdata[i] == \' \' {\n            req.method = sdata[s:i]\n            for i, s = i+1, i+1; i < len(sdata); i++ {\n                if sdata[i] == \'?\' && q == -1 {\n                    q = i - s\n                } else if sdata[i] == \' \' {\n                    if q != -1 {\n                        req.path = sdata[s:q]\n                        req.query = req.path[q+1 : i]\n                    } else {\n                        req.path = sdata[s:i]\n                    }\n                    for i, s = i+1, i+1; i < len(sdata); i++ {\n                        if sdata[i] == \'\\n\' && sdata[i-1] == \'\\r\' {\n                            req.proto = sdata[s:i]\n                            i, s = i+1, i+1\n                            break\n                        }\n                    }\n                    break\n                }\n            }\n            break\n        }\n    }\n    if req.proto == "" {\n        return data, fmt.Errorf("malformed request")\n    }\n    head = sdata[:s]\n    for ; i < len(sdata); i++ {\n        if i > 1 && sdata[i] == \'\\n\' && sdata[i-1] == \'\\r\' {\n            line := sdata[s : i-1]\n            s = i + 1\n            if line == "" {\n                req.head = sdata[len(head)+2 : i+1]\n                i++\n                if clen > 0 {\n                    if len(sdata[i:]) < clen {\n                        break\n                    }\n                    req.body = sdata[i : i+clen]\n                    i += clen\n                }\n                return data[i:], nil\n            }\n            if strings.HasPrefix(line, "Content-Length:") {\n                n, err := strconv.ParseInt(strings.TrimSpace(line[len("Content-Length:"):]), 10, 64)\n                if err == nil {\n                    clen = int(n)\n                }\n            }\n        }\n    }\n    // not enough data\n    return data, nil\n}\n'))),Object(o.b)("details",null,Object(o.b)("summary",null," Push Server "),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-go"}),'package main\n\nimport (\n    "flag"\n    "fmt"\n    "log"\n    "sync"\n    "time"\n\n    "github.com/panjf2000/gnet"\n)\n\ntype pushServer struct {\n    *gnet.EventServer\n    tick             time.Duration\n    connectedSockets sync.Map\n}\n\nfunc (ps *pushServer) OnInitComplete(srv gnet.Server) (action gnet.Action) {\n    log.Printf("Push server is listening on %s (multi-cores: %t, loops: %d), "+\n        "pushing data every %s ...\\n", srv.Addr.String(), srv.Multicore, srv.NumEventLoop, ps.tick.String())\n    return\n}\n\nfunc (ps *pushServer) OnOpened(c gnet.Conn) (out []byte, action gnet.Action) {\n    log.Printf("Socket with addr: %s has been opened...\\n", c.RemoteAddr().String())\n    ps.connectedSockets.Store(c.RemoteAddr().String(), c)\n    return\n}\n\nfunc (ps *pushServer) OnClosed(c gnet.Conn, err error) (action gnet.Action) {\n    log.Printf("Socket with addr: %s is closing...\\n", c.RemoteAddr().String())\n    ps.connectedSockets.Delete(c.RemoteAddr().String())\n    return\n}\n\nfunc (ps *pushServer) Tick() (delay time.Duration, action gnet.Action) {\n    log.Println("It\'s time to push data to clients!!!")\n    ps.connectedSockets.Range(func(key, value interface{}) bool {\n        addr := key.(string)\n        c := value.(gnet.Conn)\n        c.AsyncWrite([]byte(fmt.Sprintf("heart beating to %s\\n", addr)))\n        return true\n    })\n    delay = ps.tick\n    return\n}\n\nfunc (ps *pushServer) React(frame []byte, c gnet.Conn) (out []byte, action gnet.Action) {\n    out = frame\n    return\n}\n\nfunc main() {\n    var port int\n    var multicore bool\n    var interval time.Duration\n    var ticker bool\n\n    // Example command: go run push.go --port 9000 --tick 1s --multicore=true\n    flag.IntVar(&port, "port", 9000, "server port")\n    flag.BoolVar(&multicore, "multicore", true, "multicore")\n    flag.DurationVar(&interval, "tick", 0, "pushing tick")\n    flag.Parse()\n    if interval > 0 {\n        ticker = true\n    }\n    push := &pushServer{tick: interval}\n    log.Fatal(gnet.Serve(push, fmt.Sprintf("tcp://:%d", port), gnet.WithMulticore(multicore), gnet.WithTicker(ticker)))\n}\n'))),Object(o.b)("details",null,Object(o.b)("summary",null," Codec Client/Server "),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Client:")),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-go"}),'// Reference https://github.com/smallnest/goframe/blob/master/_examples/goclient/client.go\n\npackage main\n\nimport (\n    "encoding/binary"\n    "fmt"\n    "net"\n\n    "github.com/smallnest/goframe"\n)\n\nfunc main() {\n    conn, err := net.Dial("tcp", "127.0.0.1:9000")\n    if err != nil {\n        panic(err)\n    }\n    defer conn.Close()\n\n    encoderConfig := goframe.EncoderConfig{\n        ByteOrder:                       binary.BigEndian,\n        LengthFieldLength:               4,\n        LengthAdjustment:                0,\n        LengthIncludesLengthFieldLength: false,\n    }\n\n    decoderConfig := goframe.DecoderConfig{\n        ByteOrder:           binary.BigEndian,\n        LengthFieldOffset:   0,\n        LengthFieldLength:   4,\n        LengthAdjustment:    0,\n        InitialBytesToStrip: 4,\n    }\n\n    fc := goframe.NewLengthFieldBasedFrameConn(encoderConfig, decoderConfig, conn)\n    err = fc.WriteFrame([]byte("hello"))\n    if err != nil {\n        panic(err)\n    }\n    err = fc.WriteFrame([]byte("world"))\n    if err != nil {\n        panic(err)\n    }\n\n    buf, err := fc.ReadFrame()\n    if err != nil {\n        panic(err)\n    }\n    fmt.Println("received: ", string(buf))\n    buf, err = fc.ReadFrame()\n    if err != nil {\n        panic(err)\n    }\n    fmt.Println("received: ", string(buf))\n}\n')),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Server:")),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-go"}),'package main\n\nimport (\n    "encoding/binary"\n    "flag"\n    "fmt"\n    "log"\n    "time"\n\n    "github.com/panjf2000/gnet"\n    "github.com/panjf2000/gnet/pool/goroutine"\n)\n\ntype codecServer struct {\n    *gnet.EventServer\n    addr       string\n    multicore  bool\n    async      bool\n    codec      gnet.ICodec\n    workerPool *goroutine.Pool\n}\n\nfunc (cs *codecServer) OnInitComplete(srv gnet.Server) (action gnet.Action) {\n    log.Printf("Test codec server is listening on %s (multi-cores: %t, loops: %d)\\n",\n        srv.Addr.String(), srv.Multicore, srv.NumEventLoop)\n    return\n}\n\nfunc (cs *codecServer) React(frame []byte, c gnet.Conn) (out []byte, action gnet.Action) {\n    if cs.async {\n        data := append([]byte{}, frame...)\n        _ = cs.workerPool.Submit(func() {\n            c.AsyncWrite(data)\n        })\n        return\n    }\n    out = frame\n    return\n}\n\nfunc testCodecServe(addr string, multicore, async bool, codec gnet.ICodec) {\n    var err error\n    if codec == nil {\n        encoderConfig := gnet.EncoderConfig{\n            ByteOrder:                       binary.BigEndian,\n            LengthFieldLength:               4,\n            LengthAdjustment:                0,\n            LengthIncludesLengthFieldLength: false,\n        }\n        decoderConfig := gnet.DecoderConfig{\n            ByteOrder:           binary.BigEndian,\n            LengthFieldOffset:   0,\n            LengthFieldLength:   4,\n            LengthAdjustment:    0,\n            InitialBytesToStrip: 4,\n        }\n        codec = gnet.NewLengthFieldBasedFrameCodec(encoderConfig, decoderConfig)\n    }\n    cs := &codecServer{addr: addr, multicore: multicore, async: async, codec: codec, workerPool: goroutine.Default()}\n    err = gnet.Serve(cs, addr, gnet.WithMulticore(multicore), gnet.WithTCPKeepAlive(time.Minute*5), gnet.WithCodec(codec))\n    if err != nil {\n        panic(err)\n    }\n}\n\nfunc main() {\n    var port int\n    var multicore bool\n\n    // Example command: go run server.go --port 9000 --multicore=true\n    flag.IntVar(&port, "port", 9000, "server port")\n    flag.BoolVar(&multicore, "multicore", true, "multicore")\n    flag.Parse()\n    addr := fmt.Sprintf("tcp://:%d", port)\n    testCodecServe(addr, multicore, false, nil)\n}\n'))),Object(o.b)("details",null,Object(o.b)("summary",null," Custom Codec Demo with Client/Server "),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"protocol intro:")),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-go"}),'// CustomLengthFieldProtocol : custom protocol\n// custom protocol header contains Version, ActionType and DataLength fields\n// its payload is Data field\ntype CustomLengthFieldProtocol struct {\n    Version    uint16\n    ActionType uint16\n    DataLength uint32\n    Data       []byte\n}\n\n\n// Encode ...\nfunc (cc *CustomLengthFieldProtocol) Encode(c gnet.Conn, buf []byte) ([]byte, error) {\n    result := make([]byte, 0)\n\n    buffer := bytes.NewBuffer(result)\n\n    // take out the param that `React()` event saved.\n    item := c.Context().(CustomLengthFieldProtocol)\n\n\n    if err := binary.Write(buffer, binary.BigEndian, item.Version); err != nil {\n        s := fmt.Sprintf("Pack version error , %v", err)\n        return nil, errors.New(s)\n    }\n\n    if err := binary.Write(buffer, binary.BigEndian, item.ActionType); err != nil {\n        s := fmt.Sprintf("Pack type error , %v", err)\n        return nil, errors.New(s)\n    }\n    dataLen := uint32(len(buf))\n    if err := binary.Write(buffer, binary.BigEndian, dataLen); err != nil {\n        s := fmt.Sprintf("Pack datalength error , %v", err)\n        return nil, errors.New(s)\n    }\n    if dataLen > 0 {\n        if err := binary.Write(buffer, binary.BigEndian, buf); err != nil {\n            s := fmt.Sprintf("Pack data error , %v", err)\n            return nil, errors.New(s)\n        }\n    }\n\n    return buffer.Bytes(), nil\n}\n\n// Decode ...\nfunc (cc *CustomLengthFieldProtocol) Decode(c gnet.Conn) ([]byte, error) {\n    // parse header\n    headerLen := DefaultHeadLength // uint16+uint16+uint32\n    if size, header := c.ReadN(headerLen); size == headerLen {\n        byteBuffer := bytes.NewBuffer(header)\n        var pbVersion, actionType uint16\n        var dataLength uint32\n        binary.Read(byteBuffer, binary.BigEndian, &pbVersion)\n        binary.Read(byteBuffer, binary.BigEndian, &actionType)\n        binary.Read(byteBuffer, binary.BigEndian, &dataLength)\n        // to check the protocol version and actionType,\n        // reset buffer if the version or actionType is not correct\n        if pbVersion != DefaultProtocolVersion || isCorrectAction(actionType) == false {\n            c.ResetBuffer()\n            log.Println("not normal protocol:", pbVersion, DefaultProtocolVersion, actionType, dataLength)\n            return nil, errors.New("not normal protocol")\n        }\n        // parse payload\n        dataLen := int(dataLength) // max int32 can contain 210MB payload\n        protocolLen := headerLen + dataLen\n        if dataSize, data := c.ReadN(protocolLen); dataSize == protocolLen {\n            c.ShiftN(protocolLen)\n            // log.Println("parse success:", data, dataSize)\n\n            // return the payload of the data\n            return data[headerLen:], nil\n        }\n        // log.Println("not enough payload data:", dataLen, protocolLen, dataSize)\n        return nil, errors.New("not enough payload data")\n\n    }\n    // log.Println("not enough header data:", size)\n    return nil, errors.New("not enough header data")\n}\n')),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Client/Server:"),"\n",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"https://github.com/gnet-io/gnet-examples/tree/master/examples/custom_codec"}),"Check out the source code"),".")),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"For more details, check out here: ",Object(o.b)("a",Object(r.a)({parentName:"strong"},{href:"https://github.com/gnet-io/gnet-examples/tree/master/examples"}),"all examples of gnet"),".")),Object(o.b)("h2",{id:"io-events"},"I/O Events"),Object(o.b)("p",null,"Current supported I/O events in ",Object(o.b)("inlineCode",{parentName:"p"},"gnet"),":"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"EventHandler.OnInitComplete")," fires when the server has been initialized and ready to accept new connections."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"EventHandler.OnOpened")," fires once a connection has been opened."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"EventHandler.OnClosed")," fires after a connection has been closed."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"EventHandler.React")," fires when the server receives inbound data from a socket/connection. (usually it is where you write the code of business logic)"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"EventHandler.Tick")," fires right after the server starts and then fires every specified interval."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"EventHandler.PreWrite")," fires just before any data has been written to client.")),Object(o.b)("h2",{id:"ticker"},"Ticker"),Object(o.b)("p",null,"The ",Object(o.b)("inlineCode",{parentName:"p"},"EventHandler.Tick")," event fires ticks at a specified interval.\nThe first tick fires right after the gnet server starts up and if you intend to set up a ticker event, don't forget to pass an option: ",Object(o.b)("inlineCode",{parentName:"p"},"gnet.WithTicker(true)")," to ",Object(o.b)("inlineCode",{parentName:"p"},"gnet.Serve"),"."),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-go"}),'events.Tick = func() (delay time.Duration, action Action){\n    log.Printf("tick")\n    delay = time.Second\n    return\n}\n')),Object(o.b)("h2",{id:"udp"},"UDP"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"gnet")," supports UDP protocol so the ",Object(o.b)("inlineCode",{parentName:"p"},"gnet.Serve")," method can bind to UDP addresses. "),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"All incoming and outgoing packets will not be buffered but read and sent directly."),Object(o.b)("li",{parentName:"ul"},"The ",Object(o.b)("inlineCode",{parentName:"li"},"EventHandler.OnOpened")," and ",Object(o.b)("inlineCode",{parentName:"li"},"EventHandler.OnClosed")," events are not available for UDP sockets, only the ",Object(o.b)("inlineCode",{parentName:"li"},"React")," event."),Object(o.b)("li",{parentName:"ul"},"The UDP equivalents of  ",Object(o.b)("inlineCode",{parentName:"li"},"AsyncWrite([]byte)")," in TCP is ",Object(o.b)("inlineCode",{parentName:"li"},"SendTo([]byte)"),".")),Object(o.b)("h2",{id:"unix-domain-socket"},"Unix Domain Socket"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"gnet"),' also supports UDS(Unix Domain Socket), just pass the UDS addresses like "unix://xxx" to the ',Object(o.b)("inlineCode",{parentName:"p"},"gnet.Serve")," method and you could play with it."),Object(o.b)("p",null,"It is nothing different from making use of TCP when doing stuff with UDS, so the ",Object(o.b)("inlineCode",{parentName:"p"},"gnet")," UDS servers are able to leverage all event functions which are available under TCP protocol."),Object(o.b)("h2",{id:"multi-threads"},"Multi-threads"),Object(o.b)("p",null,"The ",Object(o.b)("inlineCode",{parentName:"p"},"gnet.WithMulticore(true)")," indicates whether the server will be effectively created with multi-cores, if so, then you must take care of synchronizing memory between all event callbacks, otherwise, it will run the server with a single thread. The number of threads in the server will be automatically assigned to the value of ",Object(o.b)("inlineCode",{parentName:"p"},"runtime.NumCPU()"),"."),Object(o.b)("h2",{id:"load-balancing"},"Load Balancing"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"gnet")," currently supports three load balancing algorithms: ",Object(o.b)("inlineCode",{parentName:"p"},"Round-Robin"),", ",Object(o.b)("inlineCode",{parentName:"p"},"Source-Addr-Hash")," and ",Object(o.b)("inlineCode",{parentName:"p"},"Least-Connections"),", you are able to decide which algorithm to use by passing the functional option ",Object(o.b)("inlineCode",{parentName:"p"},"LB")," (RoundRobin/LeastConnections/SourceAddrHash) to ",Object(o.b)("inlineCode",{parentName:"p"},"gnet.Serve"),"."),Object(o.b)("p",null,"If the load balancing algorithm is not specified explicitly, ",Object(o.b)("inlineCode",{parentName:"p"},"gnet")," will use ",Object(o.b)("inlineCode",{parentName:"p"},"Round-Robin")," by default."),Object(o.b)("h2",{id:"so_reuseport"},"SO_REUSEPORT"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"gnet")," server is able to utilize the ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"https://lwn.net/Articles/542629/"}),"SO_REUSEPORT")," option which allows multiple sockets on the same host to bind to the same port and the OS kernel takes care of the load balancing for you, it wakes one socket per ",Object(o.b)("inlineCode",{parentName:"p"},"connect")," event coming to resolved the ",Object(o.b)("inlineCode",{parentName:"p"},"thundering herd"),"."),Object(o.b)("p",null,"By default, ",Object(o.b)("inlineCode",{parentName:"p"},"gnet")," is not going to be haunted by the ",Object(o.b)("inlineCode",{parentName:"p"},"thundering herd")," under its networking model:\u300emultiple reactors\u300fwhich gets only ",Object(o.b)("strong",{parentName:"p"},"one"),' main reactor to listen on "address:port" and accept new sockets. So this ',Object(o.b)("inlineCode",{parentName:"p"},"SO_REUSEPORT")," option is trivial in ",Object(o.b)("inlineCode",{parentName:"p"},"gnet")," but note that it will fall back to the old networking model of ",Object(o.b)("inlineCode",{parentName:"p"},"evio")," when you enable the ",Object(o.b)("inlineCode",{parentName:"p"},"SO_REUSEPORT")," option."),Object(o.b)("p",null,"Just use functional options to set up ",Object(o.b)("inlineCode",{parentName:"p"},"SO_REUSEPORT")," and you can enjoy this feature:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-go"}),'gnet.Serve(events, "tcp://:9000", gnet.WithMulticore(true), gnet.WithReusePort(true)))\n')),Object(o.b)("h2",{id:"multiple-built-in-codecs-for-tcp-stream"},"Multiple built-in codecs for TCP stream"),Object(o.b)("p",null,"There are multiple built-in codecs in ",Object(o.b)("inlineCode",{parentName:"p"},"gnet")," which allow you to encode/decode frames into/from TCP stream."),Object(o.b)("p",null,"So far ",Object(o.b)("inlineCode",{parentName:"p"},"gnet")," has four kinds of built-in codecs: LineBasedFrameCodec, DelimiterBasedFrameCodec, FixedLengthFrameCodec and LengthFieldBasedFrameCodec, which generally meets most scenarios, but still ",Object(o.b)("inlineCode",{parentName:"p"},"gnet")," allows users to customize their own codecs in their ",Object(o.b)("inlineCode",{parentName:"p"},"gnet")," servers by implementing the interface ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"https://pkg.go.dev/github.com/panjf2000/gnet?tab=doc#ICodec"}),"gnet.ICodec")," and replacing the default codec in ",Object(o.b)("inlineCode",{parentName:"p"},"gnet")," with customized codec via functional options."),Object(o.b)("p",null,"Here is an ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"https://github.com/gnet-io/gnet-examples/tree/master/examples/codec"}),"example")," with codec, showing you how to leverage codec to encode/decode network frames into/from TCP stream."),Object(o.b)("h1",{id:"-performance"},"\ud83d\udcca Performance"),Object(o.b)("h2",{id:"benchmarks-on-techempower"},"Benchmarks on TechEmpower"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-powershell"}),"# Hardware Environment\nCPU: 28 HT Cores Intel(R) Xeon(R) Gold 5120 CPU @ 2.20GHz\nMem: 32GB RAM\nOS : Ubuntu 18.04.3 4.15.0-88-generic #88-Ubuntu\nNet: Switched 10-gigabit ethernet\nGo : go1.14.x linux/amd64\n")),Object(o.b)("p",null,Object(o.b)("img",Object(r.a)({parentName:"p"},{src:"https://raw.githubusercontent.com/panjf2000/illustrations/master/benchmark/techempower-all.jpg",alt:"All languages"}))),Object(o.b)("p",null,"This is the ",Object(o.b)("strong",{parentName:"p"},Object(o.b)("em",{parentName:"strong"},"top 50"))," on the framework ranking of all programming languages consists of a total of ",Object(o.b)("strong",{parentName:"p"},Object(o.b)("em",{parentName:"strong"},"422 frameworks"))," from all over the world where ",Object(o.b)("inlineCode",{parentName:"p"},"gnet")," is the ",Object(o.b)("strong",{parentName:"p"},Object(o.b)("em",{parentName:"strong"},"runner-up")),"."),Object(o.b)("p",null,Object(o.b)("img",Object(r.a)({parentName:"p"},{src:"https://raw.githubusercontent.com/panjf2000/illustrations/master/benchmark/techempower-go.png",alt:"Golang"}))),Object(o.b)("p",null,"This is the full framework ranking of Go and ",Object(o.b)("inlineCode",{parentName:"p"},"gnet")," tops all the other frameworks, which makes ",Object(o.b)("inlineCode",{parentName:"p"},"gnet")," the ",Object(o.b)("strong",{parentName:"p"},Object(o.b)("em",{parentName:"strong"},"fastest"))," networking framework in Go."),Object(o.b)("p",null,"To see the full ranking list, visit ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"https://www.techempower.com/benchmarks/#section=test&runid=53c6220a-e110-466c-a333-2e879fea21ad&hw=ph&test=plaintext"}),"TechEmpower Plaintext Benchmark"),"."),Object(o.b)("h2",{id:"contrasts-to-the-similar-networking-libraries"},"Contrasts to the similar networking libraries"),Object(o.b)("h2",{id:"on-linux-epoll"},"On Linux (epoll)"),Object(o.b)("h3",{id:"test-environment"},"Test Environment"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-powershell"}),"# Machine information\n        OS : Ubuntu 18.04/x86_64\n       CPU : 8 Virtual CPUs\n    Memory : 16.0 GiB\n\n# Go version and configurations\nGo Version : go1.12.9 linux/amd64\nGOMAXPROCS=8\n")),Object(o.b)("h4",{id:"echo-server"},"Echo Server"),Object(o.b)("p",null,Object(o.b)("img",Object(r.a)({parentName:"p"},{src:"https://github.com/panjf2000/gnet_benchmarks/raw/master/results/echo_linux.png",alt:null}))),Object(o.b)("h4",{id:"http-server"},"HTTP Server"),Object(o.b)("p",null,Object(o.b)("img",Object(r.a)({parentName:"p"},{src:"https://github.com/panjf2000/gnet_benchmarks/raw/master/results/http_linux.png",alt:null}))),Object(o.b)("h2",{id:"on-freebsd-kqueue"},"On FreeBSD (kqueue)"),Object(o.b)("h3",{id:"test-environment-1"},"Test Environment"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-powershell"}),"# Machine information\n        OS : macOS Mojave 10.14.6/x86_64\n       CPU : 4 CPUs\n    Memory : 8.0 GiB\n\n# Go version and configurations\nGo Version : go version go1.12.9 darwin/amd64\nGOMAXPROCS=4\n")),Object(o.b)("h4",{id:"echo-server-1"},"Echo Server"),Object(o.b)("p",null,Object(o.b)("img",Object(r.a)({parentName:"p"},{src:"https://github.com/panjf2000/gnet_benchmarks/raw/master/results/echo_mac.png",alt:null}))),Object(o.b)("h4",{id:"http-server-1"},"HTTP Server"),Object(o.b)("p",null,Object(o.b)("img",Object(r.a)({parentName:"p"},{src:"https://github.com/panjf2000/gnet_benchmarks/raw/master/results/http_mac.png",alt:null}))),Object(o.b)("h1",{id:"\ufe0f-license"},"\ufe0f\ud83d\udea8 License"),Object(o.b)("p",null,"Source code in ",Object(o.b)("inlineCode",{parentName:"p"},"gnet")," is available under the ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"https://github.com/panjf2000/gnet/blob/master/LICENSE"}),"MIT License"),"."),Object(o.b)("h1",{id:"-contributors"},"\ud83d\udc4f Contributors"),Object(o.b)("p",null,"Please read the ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"https://github.com/panjf2000/gnet/blob/master/CONTRIBUTING.md"}),"Contributing Guidelines")," before opening a PR and thank you to all the developers who already made contributions to ",Object(o.b)("inlineCode",{parentName:"p"},"gnet"),"!"),Object(o.b)("p",null,Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"https://github.com/panjf2000/gnet/graphs/contributors"}),Object(o.b)("img",Object(r.a)({parentName:"a"},{src:"https://opencollective.com/gnet/contributors.svg?width=890&button=false",alt:null})))),Object(o.b)("h1",{id:"-acknowledgments"},"\ud83d\ude4f Acknowledgments"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",Object(r.a)({parentName:"li"},{href:"https://github.com/tidwall/evio"}),"evio")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",Object(r.a)({parentName:"li"},{href:"https://github.com/netty/netty"}),"netty")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",Object(r.a)({parentName:"li"},{href:"https://github.com/panjf2000/ants"}),"ants")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",Object(r.a)({parentName:"li"},{href:"https://github.com/kavu/go_reuseport"}),"go_reuseport")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",Object(r.a)({parentName:"li"},{href:"https://github.com/valyala/bytebufferpool"}),"bytebufferpool")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",Object(r.a)({parentName:"li"},{href:"https://github.com/smallnest/goframe"}),"goframe")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",Object(r.a)({parentName:"li"},{href:"https://github.com/smallnest/ringbuffer"}),"ringbuffer"))),Object(o.b)("h1",{id:"-relevant-articles"},"\u2693 Relevant Articles"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",Object(r.a)({parentName:"li"},{href:"https://www.freecodecamp.org/news/million-websockets-and-go-cc58418460bb/"}),"A Million WebSockets and Go")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",Object(r.a)({parentName:"li"},{href:"https://speakerdeck.com/eranyanay/going-infinite-handling-1m-websockets-connections-in-go"}),"Going Infinite, handling 1M websockets connections in Go")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",Object(r.a)({parentName:"li"},{href:"https://taohuawu.club/go-netpoll-io-multiplexing-reactor"}),"Go netpoll I/O \u591a\u8def\u590d\u7528\u6784\u5efa\u539f\u751f\u7f51\u7edc\u6a21\u578b\u4e4b\u6e90\u7801\u6df1\u5ea6\u89e3\u6790")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",Object(r.a)({parentName:"li"},{href:"https://taohuawu.club/go-event-loop-networking-library-gnet"}),"gnet: \u4e00\u4e2a\u8f7b\u91cf\u7ea7\u4e14\u9ad8\u6027\u80fd\u7684 Golang \u7f51\u7edc\u5e93")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",Object(r.a)({parentName:"li"},{href:"https://taohuawu.club/releasing-gnet-v1-with-techempower"}),"\u6700\u5feb\u7684 Go \u7f51\u7edc\u6846\u67b6 gnet \u6765\u5566\uff01")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",Object(r.a)({parentName:"li"},{href:"https://taohuawu.club/bytedance-network-library-practices"}),"\u5b57\u8282\u8df3\u52a8\u5728 Go \u7f51\u7edc\u5e93\u4e0a\u7684\u5b9e\u8df5"))),Object(o.b)("h1",{id:"-backers"},"\ud83d\udcb0 Backers"),Object(o.b)("p",null,"Support us with a monthly donation and help us continue our activities."),Object(o.b)("a",{href:"https://opencollective.com/gnet#backers",target:"_blank"},Object(o.b)("img",{src:"https://opencollective.com/gnet/backers.svg"})),Object(o.b)("h1",{id:"-sponsors"},"\ud83d\udc8e Sponsors"),Object(o.b)("p",null,"Become a bronze sponsor with a monthly donation of $10 and get your logo on our README on Github."),Object(o.b)("a",{href:"https://opencollective.com/gnet#sponsors",target:"_blank"},Object(o.b)("img",{src:"https://opencollective.com/gnet/sponsors.svg"})),Object(o.b)("h1",{id:"\ufe0f-buy-me-a-coffee"},"\u2615\ufe0f Buy me a coffee"),Object(o.b)("blockquote",null,Object(o.b)("p",{parentName:"blockquote"},"Please be sure to leave your name, Github account or other social media accounts when you donate by the following means so that I can add it to the list of donors as a token of my appreciation.")),Object(o.b)("table",null,Object(o.b)("tr",null,Object(o.b)("td",null,Object(o.b)("img",{src:"https://raw.githubusercontent.com/panjf2000/illustrations/master/payments/WeChatPay.JPG",width:"250"})),Object(o.b)("td",null,Object(o.b)("img",{src:"https://raw.githubusercontent.com/panjf2000/illustrations/master/payments/AliPay.JPG",width:"250"})),Object(o.b)("td",null,Object(o.b)("a",{href:"https://www.paypal.me/R136a1X",target:"_blank"},Object(o.b)("img",{src:"https://raw.githubusercontent.com/panjf2000/illustrations/master/payments/PayPal.JPG",width:"250"}))))),Object(o.b)("h1",{id:"-donors"},"\ud83d\udcb4 Donors"),Object(o.b)("a",{target:"_blank",href:"https://github.com/patrick-othmer"},Object(o.b)("img",{src:"https://avatars1.githubusercontent.com/u/8964313",width:"100",alt:"Patrick Othmer"})),"\xa0\xa0",Object(o.b)("a",{target:"_blank",href:"https://github.com/panjf2000/gnet"},Object(o.b)("img",{src:"https://avatars2.githubusercontent.com/u/50285334",width:"100",alt:"Jimmy"})),"\xa0\xa0",Object(o.b)("a",{target:"_blank",href:"https://github.com/cafra"},Object(o.b)("img",{src:"https://avatars0.githubusercontent.com/u/13758306",width:"100",alt:"ChenZhen"})),"\xa0\xa0",Object(o.b)("a",{target:"_blank",href:"https://github.com/yangwenmai"},Object(o.b)("img",{src:"https://avatars0.githubusercontent.com/u/1710912",width:"100",alt:"Mai Yang"})),"\xa0\xa0",Object(o.b)("a",{target:"_blank",href:"https://github.com/BeijingWks"},Object(o.b)("img",{src:"https://avatars3.githubusercontent.com/u/33656339",width:"100",alt:"\u738b\u5f00\u5e05"})),Object(o.b)("h1",{id:"-paid-support"},"\ud83d\udcb5 Paid Support"),Object(o.b)("p",{align:"center"},Object(o.b)("a",{title:"XS:CODE",target:"_blank",href:"https://xscode.com/panjf2000/gnet"},Object(o.b)("img",{src:"https://raw.githubusercontent.com/panjf2000/illustrations/master/go/gnet-banner.png"}))),Object(o.b)("p",null,"If you need a tailored version of ",Object(o.b)("inlineCode",{parentName:"p"},"gnet")," and want the author to help develop it, or bug fix/fast resolution/consultation which takes a lot of effort, you can request paid support ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"https://xscode.com/panjf2000/gnet"}),"here"),"."),Object(o.b)("h1",{id:"-jetbrains-os-licenses"},"\ud83d\udd11 JetBrains OS licenses"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"gnet")," had been being developed with ",Object(o.b)("inlineCode",{parentName:"p"},"GoLand")," IDE under the ",Object(o.b)("strong",{parentName:"p"},"free JetBrains Open Source license(s)")," granted by JetBrains s.r.o., hence I would like to express my thanks here."),Object(o.b)("a",{href:"https://www.jetbrains.com/?from=gnet",target:"_blank"},Object(o.b)("img",{src:"https://raw.githubusercontent.com/panjf2000/illustrations/master/jetbrains/jetbrains-variant-4.png",width:"250",align:"middle"})),Object(o.b)("h1",{id:"-sponsorship"},"\ud83d\udd0b Sponsorship"),Object(o.b)("p",null,Object(o.b)("h3",null,"This project is supported by:"),Object(o.b)("a",{href:"https://www.digitalocean.com/"},Object(o.b)("img",{src:"https://opensource.nyc3.cdn.digitaloceanspaces.com/attribution/assets/SVG/DO_Logo_horizontal_blue.svg",width:"201px"}))))}b.isMDXComponent=!0},213:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return m}));var r=n(0),a=n.n(r);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function c(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=a.a.createContext({}),b=function(e){var t=a.a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):c({},t,{},e)),n},p=function(e){var t=b(e.components);return a.a.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},d=Object(r.forwardRef)((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,i=e.parentName,s=l(e,["components","mdxType","originalType","parentName"]),p=b(n),d=r,m=p["".concat(i,".").concat(d)]||p[d]||u[d]||o;return n?a.a.createElement(m,c({ref:t},s,{components:n})):a.a.createElement(m,c({ref:t},s))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=d;var c={};for(var l in t)hasOwnProperty.call(t,l)&&(c[l]=t[l]);c.originalType=e,c.mdxType="string"==typeof e?e:r,i[1]=c;for(var s=2;s<o;s++)i[s]=n[s];return a.a.createElement.apply(null,i)}return a.a.createElement.apply(null,n)}d.displayName="MDXCreateElement"}}]);